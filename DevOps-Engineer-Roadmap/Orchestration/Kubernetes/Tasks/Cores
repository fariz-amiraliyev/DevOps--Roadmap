Administer a Cluster:
Manage Memory, CPU, and API Resources
Install a Network Policy Provider
Access Clusters Using the Kubernetes API
Access Services Running on Clusters
Advertise Extended Resources for a Node
Autoscale the DNS Service in a Cluster
Change the default StorageClass
Change the Reclaim Policy of a PersistentVolume
Cloud Controller Manager Administration
Cluster Management
Configure Out of Resource Handling
Configure Quotas for API Objects
Control CPU Management Policies on the Node
Control Topology Management Policies on a node
Customizing DNS Service
Debugging DNS Resolution
Declare Network Policy
Developing Cloud Controller Manager
Enabling EndpointSlices
Enabling Service Topology
Encrypting Secret Data at Rest
Guaranteed Scheduling For Critical Add-On Pods
IP Masquerade Agent User Guide
Limit Storage Consumption
Namespaces Walkthrough
Operating etcd clusters for Kubernetes
Reconfigure a Node's Kubelet in a Live Cluster
Reserve Compute Resources for System Daemons
Safely Drain a Node while Respecting the PodDisruptionBudget
Securing a Cluster
Set Kubelet parameters via a config file
Set up High-Availability Kubernetes Masters
Share a Cluster with Namespaces
Using a KMS provider for data encryption
Using CoreDNS for Service Discovery
Using NodeLocal DNSCache in Kubernetes clusters
Using sysctls in a Kubernetes Cluster


Configure Pods and Containers:
Assign Memory Resources to Containers and Pods
Assign CPU Resources to Containers and Pods
Configure GMSA for Windows Pods and containers
Configure RunAsUserName for Windows pods and containers
Configure Quality of Service for Pods
Assign Extended Resources to a Container
Configure a Pod to Use a Volume for Storage
Configure a Pod to Use a PersistentVolume for Storage
Configure a Pod to Use a Projected Volume for Storage
Configure a Security Context for a Pod or Container
Configure Service Accounts for Pods
Pull an Image from a Private Registry
Configure Liveness, Readiness and Startup Probes
Assign Pods to Nodes
Assign Pods to Nodes using Node Affinity
Configure Pod Initialization
Attach Handlers to Container Lifecycle Events
Configure a Pod to Use a ConfigMap
Share Process Namespace between Containers in a Pod
Create static Pods
Translate a Docker Compose File to Kubernetes Resources

Manage Kubernetes Objects
Declarative and imperative paradigms for interacting with the Kubernetes API.
Declarative Management of Kubernetes Objects Using Configuration Files
Declarative Management of Kubernetes Objects Using Kustomize
Managing Kubernetes Objects Using Imperative Commands
Imperative Management of Kubernetes Objects Using Configuration Files
Update API Objects in Place Using kubectl patch
Use kubectl patch to update Kubernetes API objects in place.
Do a strategic merge patch or a JSON merge patch.

Managing Secrets
Managing confidential settings data using Secrets.
Managing Secret using `kubectl`
Creating Secret objects using kubectl command line.
Managing Secret using Configuration File
Creating Secret objects using resource configuration file.
Managing Secret using Kustomize
Creating Secret objects using kustomization.yaml file.

Inject Data Into Applications
Specify configuration and other data for the Pods that run your workload.
Define a Command and Arguments for a Container
Define Dependent Environment Variables
Define Environment Variables for a Container
Expose Pod Information to Containers Through Environment Variables
Expose Pod Information to Containers Through Files
Distribute Credentials Securely Using Secrets
Inject Information into Pods Using a PodPreset

Run Applications
Run and manage both stateless and stateful applications.
Run a Stateless Application Using a Deployment
Run a Single-Instance Stateful Application
Run a Replicated Stateful Application
Scale a StatefulSet
Delete a StatefulSet
Force Delete StatefulSet Pods
Horizontal Pod Autoscaler
Horizontal Pod Autoscaler Walkthrough
Specifying a Disruption Budget for your Application

Run Jobs
Run Jobs using parallel processing.
Running Automated Tasks with a CronJob
Parallel Processing using Expansions
Coarse Parallel Processing Using a Work Queue
Fine Parallel Processing Using a Work Queue

Access Applications in a Cluster
Configure load balancing, port forwarding, or setup firewall or
DNS configurations to access applications in a cluster.
Web UI (Dashboard)
Accessing Clusters
Configure Access to Multiple Clusters
Use Port Forwarding to Access Applications in a Cluster
Use a Service to Access an Application in a Cluster
Connect a Front End to a Back End Using a Service
Create an External Load Balancer
List All Container Images Running in a Cluster
Set up Ingress on Minikube with the NGINX Ingress Controller
Communicate Between Containers in the Same Pod Using a Shared Volume
Configure DNS for a Cluster

Monitoring, Logging, and Debugging
Set up monitoring and logging to troubleshoot a cluster, or debug a containerized application.
Application Introspection and Debugging
Auditing
Debug a StatefulSet
Debug Init Containers
Debug Pods and ReplicationControllers
Debug Running Pods
Debug Services
Debugging Kubernetes nodes with crictl
Determine the Reason for Pod Failure
Developing and debugging services locally
Events in Stackdriver
Get a Shell to a Running Container
Logging Using Elasticsearch and Kibana
Logging Using Stackdriver
Monitor Node Health
Resource metrics pipeline
Tools for Monitoring Resources
Troubleshoot Applications
Troubleshoot Clusters
Troubleshooting


Extend Kubernetes
Understand advanced ways to adapt your Kubernetes cluster to the needs
of your work environment.
Configure the Aggregation Layer
Use Custom Resources
Set up an Extension API Server
Configure Multiple Schedulers
Use an HTTP Proxy to Access the Kubernetes API
Set up Konnectivity service

TLS
Understand how to protect traffic within your cluster using Transport Layer Security (TLS).
Configure Certificate Rotation for the Kubelet
Manage TLS Certificates in a Cluster
Manual Rotation of CA Certificates

Manage Cluster Daemons
Perform common tasks for managing a DaemonSet, such as performing a rolling update.
Perform a Rolling Update on a DaemonSet
Perform a Rollback on a DaemonSet

Service Catalog
Install the Service Catalog extension API.
Install Service Catalog using Helm
Install Service Catalog using SC

Networking
Learn how to configure networking for your cluster.
Validate IPv4/IPv6 dual-stack


Extend kubectl with plugins
Extend kubectl by creating and installing kubectl plugins.
https://kubernetes.io/docs/tasks/extend-kubectl/kubectl-plugins/


Manage HugePages
Configure and manage huge pages as a schedulable resource in a cluster.
https://kubernetes.io/docs/tasks/manage-hugepages/scheduling-hugepages/


Schedule GPUs
Configure and schedule GPUs for use as a resource by nodes in a cluster.
